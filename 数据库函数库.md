本章将设计一个简单的、多用户数据库的函数库。通过此函数库提供的 C语言函数，其他程序可以访问数据库中的记录。这个 C函数库只是一个完整的数据库的很小的一部分，并不包括其他很多部分。

#### 函数库

当打开一个数据库时，通过返回值得到一个 DB结构的指针。这一点很像通过fopen得到一个FILE结构的指针，以及通过opendir得到一个DIR结构的指针。我们将用此指针作为参数来调用以后的数据库函数。

如果db_open成功返回，则将建立两个文件： pathname.idx 和pathname.dat，pathname.idx是索引文件， pathname.dat是数据文件。

当不再使用数据库时，调用 db_close来关闭数据库。  db_close将关闭索引文件和数据文件，并释放数据库使用过程中分配的所有用于内部缓冲的存储空间。

#### 实现概述

有许多技术可用来组织索引文件以提高按关键字查询的速度和效率，散列表和 B+树是两种常用的技术。我们采用固定大小的散列表来组织索引文件结构，并采用链表法解决散列冲突。

db_store要求对每个关键字，最多只有一个对应的记录。有些数据库系统允许多条记录使用同样的关键字，并提供方法访问与一个关键字相关的所有记录。另外，我们只有一个索引文件，这意味着每个数据记录只能有一个关键字。有些数据库允许一条记录拥有多个关键字，并且对每一个关键字使用一个索引文件。

散列表的大小指的是散列链的条数。

#### 集中式或非集中式

* 集中式 由一个进程作为数据库管理者，所有的数据库访问工作由此进程完成。库函数通过I P C机制与此中心进程进行联系。
* 非集中式 每个库函数独立申请并发控制（加锁），然后调用它自己的I / O函数。

#### 并发

需要对文件进行加锁，主要可以分为粗锁和细锁

* 粗锁：最简单的加锁方法是将这两个文件中的一个作为锁，并要求调用者在对数据库进行操作前
  必须获得这个锁。我们将这称为粗锁（ coarse locking）。
* 在源文件中，直接调用了read， readv， write和writev。没有使用标准I / O函数库。虽然使用标准I / O函数库也可以使用记录锁，但是需要非常复杂的缓存管理。

回到函数d b _ s t o r e，在调用_ d b _ f i n d后，有四种可能：

1. 加入一条新的记录，而 _db_findfree没有找到对应大小的空闲记录。这意味着要将这条新记录添加到索引文件和数据文件的末尾。通过调用  _db_writeptr将新记录加到对应的散列链的链首。
2. 加入一条新记录，且 _db_findfree找到对应大小的空闲记录。这条空闲记录被 _db_findfree 从空闲链表上移下来，新的索引记录和数据记录被写入，然后通过调  _db_writeptr将新记录加到对应的散列链的链首。
3. 要替换一条记录，而新数据记录的长度与已存在的记录的长度不一样。调用_db_dodelete将老记录删除，然后将新记录添加到索引文件和数据文件的末尾（也可以用其他方法，如可以再找一找是否有适当大小的已删除的记录项）。最后调用 _db_writeptr将新记录加到对应的散列链的链首。
4. 要替换一条记录，而新数据记录的长度与已存在的记录的长度恰好一样。这是最容易的情况，只需要重写记录即可。

最后两个函数是db_nextrec和db_rewind，这两个函数用来读取数据库的所有记录。

