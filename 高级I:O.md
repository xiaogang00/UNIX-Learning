#### 非阻塞I/O

* 系统调用分为低速系统调用和其他，低速系统调用可能会使得进程永远阻塞的一类系统调用。
* 非阻塞I / O使我们可以调用不会永远阻塞的 I/O操作，例如open，read和write。如果这种操作不能完成，则立即出错返回，表示该操作如继续执行将继续阻塞下去。

#### 记录锁

有时进程需要确保它正在单独写一个文件。为了向进程提供这种功能，较新的 UNIX系统提供了记录锁机制。记录锁（ record locking）的功能是：一个进程正在读或修改文件的某个部分时，可以阻止
其他进程修改同一文件区。

两种类型的锁：共享读锁（l_type为L_RDLCK）和独占写琐（ L_WRLCK）。

多个进程在一个给定的字节上可以有一把共享的读锁，但是在一个给定字节上的写锁则只能由一个进程独用。

在这两个操作之间可能会有另一个进程插入并建立一把相关的锁，使原来测试到的情况发生变化，如果不希望在建立锁时可能产生的长期阻塞，则应使用F_SETLK，并对返回结果进行测试，以判别是否成功地建立了所要求的锁。

* 锁的隐含继承和释放：
  * 锁与进程、文件两方面有关。这有两重含意：第一重很明显，当一个进程终止时，它所建立的锁全部释放；第二重意思就不很明显，任何时候关闭一个描述符时，则该进程通过这一描述符可以存访的文件上的任何一把锁都被释放。
* 防止一个精灵进程有多份副本同时运行的方法是：在精灵进程开始运行时，在它的进程I D文件上设置一把写锁。如果在它运行时一直保持这把锁，则不可能再起动它的其他副本。
* dup和dup2也是两个非常有用的调用，它们的作用都是用来复制一个文件的描述符。它们经常用来重定向进程的stdin、stdout和stderr。
* 如果该库中所有函数都以一致的方法处理记录锁，则称使用这些函数存取数据库的任何进程集为合作进程（ cooperating process）。

1. 强制性锁机制中，内核对每一个open、 read和write都要检查调用进程对正在存取的文件是否违背了某一把锁的作用。
2. 如果该库中所有函数都以一致的方法处理记录锁，则称使用这些函数存取数据库的任何进程集为合作进程。如果这些函数是唯一的用来存取数据库的函数，那么它们使用建议性锁是可行的。但是建议性锁并不能阻止对数据库文件有写许可权的任何其他进程写数据库文件。不使用协同一致的方法（数据库存取例程库）来存取数据库的进程是一个非合作进程。

#### 流

流是系统V提供的构造内核设备驱动程序和网络协议包的一种通用方法，对流进行讨论的目的是理解下列各点：

* 系统V的终端界面。
* I/O多路复用中轮询函数的使用。
* 基于流管道和命名流管道的实现。

流在用户进程和设备驱动程序之间提供了一条全双工通路。流无需和实际硬件设备直接对话—流也可以用作为伪设备驱动程序。

写到流首的数据将顺流而下传送。由设备驱动程序读到的数据则逆流向上传送。

为流打开的路径名通常在/dev目录之下。用ls -l查看设备名，就能判断该设备是否为流设备。

在用户进程和流首之间，消息由下列几部分组成：消息类型、可选择的控制信息以及可选择的数据。

流中的消息都有一个排队优先级：

*  高优先级消息（最高优先级）。
* 优先波段消息。
* 普通消息（最低优先级）。

每个流模块有两个输入队列。一个接收来自它上面模块的消息（这种消息从流首向驱动程序顺流传送）。另一个接收来自它下面模块的消息（这种消息从驱动程序向流首逆流传送）。在输入队列中的消息按优先级从高到低排列。

```
putmsg和putpmsg函数用于将流消息（控制信息或数据，或两者）写至流中。
```

流ioctl 操作能做其他I / O函数不能处理的事情。流系统中继续采用了该函数。

确定一个描述符是否引用一个流：

```
int isastream(int filedes) ;
//返回：若是流返回1，否则返回0
```

如果ioctl的参数request是I_LIST，则系统返回该流上所有模块的名字，包括最顶端的驱动程序。 

