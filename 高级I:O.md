#### 非阻塞I/O

* 系统调用分为低速系统调用和其他，低速系统调用可能会使得进程永远阻塞的一类系统调用。
* 非阻塞I / O使我们可以调用不会永远阻塞的 I/O操作，例如open，read和write。如果这种操作不能完成，则立即出错返回，表示该操作如继续执行将继续阻塞下去。

#### 记录锁

有时进程需要确保它正在单独写一个文件。为了向进程提供这种功能，较新的 UNIX系统提供了记录锁机制。记录锁（ record locking）的功能是：一个进程正在读或修改文件的某个部分时，可以阻止
其他进程修改同一文件区。

两种类型的锁：共享读锁（l_type为L_RDLCK）和独占写琐（ L_WRLCK）。

多个进程在一个给定的字节上可以有一把共享的读锁，但是在一个给定字节上的写锁则只能由一个进程独用。

在这两个操作之间可能会有另一个进程插入并建立一把相关的锁，使原来测试到的情况发生变化，如果不希望在建立锁时可能产生的长期阻塞，则应使用F_SETLK，并对返回结果进行测试，以判别是否成功地建立了所要求的锁。

* 锁的隐含继承和释放：
  * 锁与进程、文件两方面有关。这有两重含意：第一重很明显，当一个进程终止时，它所建立的锁全部释放；第二重意思就不很明显，任何时候关闭一个描述符时，则该进程通过这一描述符可以存访的文件上的任何一把锁都被释放。
* 防止一个精灵进程有多份副本同时运行的方法是：在精灵进程开始运行时，在它的进程I D文件上设置一把写锁。如果在它运行时一直保持这把锁，则不可能再起动它的其他副本。
* dup和dup2也是两个非常有用的调用，它们的作用都是用来复制一个文件的描述符。它们经常用来重定向进程的stdin、stdout和stderr。
* 如果该库中所有函数都以一致的方法处理记录锁，则称使用这些函数存取数据库的任何进程集为合作进程（ cooperating process）。

1. 强制性锁机制中，内核对每一个open、 read和write都要检查调用进程对正在存取的文件是否违背了某一把锁的作用。
2. 如果该库中所有函数都以一致的方法处理记录锁，则称使用这些函数存取数据库的任何进程集为合作进程。如果这些函数是唯一的用来存取数据库的函数，那么它们使用建议性锁是可行的。但是建议性锁并不能阻止对数据库文件有写许可权的任何其他进程写数据库文件。不使用协同一致的方法（数据库存取例程库）来存取数据库的进程是一个非合作进程。

#### 流

流是系统V提供的构造内核设备驱动程序和网络协议包的一种通用方法，对流进行讨论的目的是理解下列各点：

* 系统V的终端界面。
* I/O多路复用中轮询函数的使用。
* 基于流管道和命名流管道的实现。

流在用户进程和设备驱动程序之间提供了一条全双工通路。流无需和实际硬件设备直接对话—流也可以用作为伪设备驱动程序。

写到流首的数据将顺流而下传送。由设备驱动程序读到的数据则逆流向上传送。

为流打开的路径名通常在/dev目录之下。用ls -l查看设备名，就能判断该设备是否为流设备。

在用户进程和流首之间，消息由下列几部分组成：消息类型、可选择的控制信息以及可选择的数据。

流中的消息都有一个排队优先级：

*  高优先级消息（最高优先级）。
* 优先波段消息。
* 普通消息（最低优先级）。

每个流模块有两个输入队列。一个接收来自它上面模块的消息（这种消息从流首向驱动程序顺流传送）。另一个接收来自它下面模块的消息（这种消息从驱动程序向流首逆流传送）。在输入队列中的消息按优先级从高到低排列。

```
putmsg和putpmsg函数用于将流消息（控制信息或数据，或两者）写至流中。
```

流ioctl 操作能做其他I / O函数不能处理的事情。流系统中继续采用了该函数。

确定一个描述符是否引用一个流：

```
int isastream(int filedes) ;
//返回：若是流返回1，否则返回0
```

如果ioctl的参数request是I_LIST，则系统返回该流上所有模块的名字，包括最顶端的驱动程序。 

write至流设备在表1 2 - 4中可以看到write至流设备产生一个M_DATA消息。一般而言，这确实如此，但是也还有一些情况需要考虑。首先，流中顶部的一个处理模块规定了可顺流传送的最小、最大数据包长度。

当从一个描述符读，然后又写到另一个描述符时，可以在下列形式的循环中使用阻塞 I / O：

```c
while((n=read(STDIN_FILENO, buf, BUFSIZ))>0)
    if(write(STDOUT_FILENO, buf, n) != n)
       err_sys("write error");
```

* select函数使我们在SVR4和4.3+BSD之下可以执行I/O多路转接，传向select的参数告诉内核：

  (1) 我们所关心的描述符。

  (2) 对于每个描述符我们所关心的条件（是否读一个给定的描述符？是否想写一个给定的描述符？是否关心一个描述符的异常条件？）。

  (3) 希望等待多长时间（可以永远等待，等待一个固定量时间，或完全不等待）。

  从s e l e c t返回时，内核告诉我们：

  (1) 已准备好的描述符的数量。

  (2) 哪一个描述符已准备好读、写或异常条件

* 与select不同， poll不是为每个条件构造一个描述符集，而是构造一个 pollfd结构数组，每个数组元素指定一个描述符编号以及对其所关心的条件。

* 使用select和poll可以实现异步I / O。关于描述符的状态,系统并不主动告诉我们任何信息 ,我们需要主动地进行查询。

* 为了对一个流设备起动异步 I/O，需要调用 ioctl，而其第二个参数（request）则为I_SETSIG。第三个参数则是由表 12- 6中一个或多个常数构成的整型值。这些常数在 < stropts.h >中定义。

* readv和writev函数
  readv和writev函数用于在一个函数调用中读、写多个非连续缓存。有时也将这两个函数称为散布读

  （ scatter read）和聚集写（ gather write）

  这两个函数的第二个参数是指向 i o v e c结构数组的一个指针

* writev以顺序iov[0], iov[ 1 ]至iov[iovcnt-1] 从缓存中聚集输出数据。 writev返回输出的字节总数，它应等于所有缓存长度之和。

* readv则将读入的数据按上述同样顺序散布到缓存中。readv总是先填满一个缓存，然后再填写下一个。readv返回读得的总字节数。如果遇到文件结尾，已无数据可读，则返回 0。

* 两个函数 readn和writen的功能是读、写指定的 N字节数据，并处理返回值小于要求值的情况。这两个函数只是按需多次调用 read和write直至读、写了N字节数据。

* 存储映射I/O：

  于是当从缓存中取数据，就相当于读文件中的相应字节。与其类似，将数据存入缓存，则相应字节就自动地写入文件。

  ```
  caddr_t mmap(caddr_t addr, size_t len,int prot,int flag, int filedes,off_t off);
  返回：若成功则为映射区的起始地址，若出错则为 - 1
  ```

  数据类型caddr_t通常定义为char *。 addr参数用于指定映射存储区的起始地址。通常将其设置为0，这表示由系统选择该映射区的起始地址。此函数的返回地址是：该映射区的起始地址。

  ​